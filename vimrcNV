" ************************ My own vimrc ******************************

     set t_Co=256
     set t_Sf=[3%dm
     set t_Sb=[4%dm
     set t_mr=[00;33;44m
     set encoding=utf-8

"PATHOGEN/VUNDLE
filetype off
"disble individual pathogen
"let g:pathogen_disabled = ['delimitMate']
" To disable a plugin, add it's bundle name to the following list
let g:pathogen_disabled = []

" for some reason the csscolor plugin is very slow when run on the terminal
" but not in GVim, so disable it if no GUI is running
if !has('gui_running')
        call add(g:pathogen_disabled, 'vim_airline')
endif
call pathogen#infect()
call pathogen#helptags()
"VUNDLE
"set rtp+=~/.vim/bundle/vundle/
"call vundle#rc()
" let Vundle manage Vundle
" required!
"Bundle 'gmarik/vundle'
" Brief help
" :BundleList          - list configured bundles
" :BundleInstall(!)    - install(update) bundles
" :BundleSearch(!) foo - search(or refresh cache first) for foo
" :BundleClean(!)      - confirm(or auto-approve) removal of unused bundles
" :BundleUpdate
"
" see :h vundle for more details or wiki for FAQ
" NOTE: comments after Bundle command are not allowed..

"syntax highlighting..
"syntax on
"filetype plugin indent on
" source neocomplete
source $HOME/.vim/neo_complete
" Solid line for vsplit separator
set fcs=vert:'|'
"
" Always splits to the right and below
"set splitright
"set splitbelow
"
" Set to auto read when a file is changed from the outside
"set autoread
"
" Set to auto write file
"set autowriteall
"
" Give one virtual space at end of line
set virtualedit=onemore

"settings handy ..
" Display an incomplete command in the lower right corner of the Vim window
set showcmd
set cpoptions=Aq
"
"allow to delete using backspace
"set backspace=2
set backspace=indent,eol,start
" Set xterm2 mouse mode to allow resizing of splits with mouse inside Tmux.
set ttymouse=xterm2
" other whitespace and indenting related settings
" auto-indent amount when using cindent, >>, << and stuff like that
set shiftwidth=4
set softtabstop=2
" multiples of shiftwidth when using >
set shiftround
set grepprg=grep\ -rnH\ --exclude='.*.swp'\ --exclude='*~'\ --exclude=tags
set sw=2
" real tabs should be 8, and they will show with set list on
set tabstop=8
"dont show statusline messages
"hide the insert mode displays
set noshowmode
"set modeline parsing
set modeline
" rt clk pops up a menu"
set mousemodel=popup
set laststatus=2 ruler wrapmargin=8
"dont refresh screen when executing macros
set lazyredraw
set expandtab
"set shiftwidth=8 tabstop=8 nowrap joinspaces magic report=0 dict=/usr/dict/words
set shell=csh wildchar=<TAB> incsearch
"set guifont=-b&h-lucidatypewriter-medium-r-normal-*-*-140-*-*-m-*-iso8859-15

" Make regex a little easier to type
set magic

" Column width indicator
set colorcolumn=+1

"set rel num and current line number"
se relativenumber
se number
se nowrapscan
se nowrap
" Turn backup off, since most stuff is in SVN, git anyway...
set nobackup
set nowritebackup
set noswapfile
se undolevels=10000
" viminfo stores the the state of your previous editing session
set viminfo+=n~/.vim/viminfo
if exists("+undofile")
  " undofile - This allows you to use undos after exiting and restarting
  " This, like swap and backups, uses .vim-undo first, then ~/.vim/undo
  " :help undo-persistence
  " This is only present in 7.3+
  "if isdirectory($HOME . '/.vim/undo') == 0
  "  :silent !mkdir -p ~/.vim/undo >& /dev/null
  "endif
  set undodir=./.vim-undo//
  set undodir+=~/.vim/undo//
  set undofile
endif
"Show matching bracets when text indicator is over them
set showmatch
se hlsearch
se diffopt+=iwhite
set linebreak
se autoindent
set smartindent
" This is a personal preference, I copy with 'as is' indent, the use '<' or '>' on visual to change it
set copyindent
" For smartindent, don't handle # specially
" don't force preprocessor lines at column 1
set cinkeys-=0#
"inoremap # X#
set smarttab
set cindent
set cinoptions=:s,ps,ts,cs
set cinwords=if,else,while,do,for,switch,case
let indent_guides_enable_on_vim_startup = 1
se ignorecase
set infercase " case inferred by default
se smartcase
"scroll offset"
set scrolloff=2 "skip 2 lines when scrolling
set iskeyword+=_
set iskeyword-='
set iskeyword-=:
""confirm action using a dialog box
set confirm
set nostartofline
" always show something in statusline
set report=0 " tell us when anything is changed via :...
"leave my cursor where it was"
"change to the current dir automatically
set autochdir
"open file in the current buffer dir
set browsedir=buffer
"change the cmd window
"set cmdheight=3
"small status msg for vim
"set shortmess=atI
"set shortmess=aOstT " shortens messages to avoid 'press a key' prompt
set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe,*.o,*.obj,*.a,*.lib,*.elf,*.dll
" Make shift-insert work like in Xterm
map <S-Insert> <MiddleMouse>
map! <S-Insert> <MiddleMouse>
" Writes to the unnamed register also writes to the * and + registers. This
" makes it easy to interact with the system clipboard
"if has ('unnamedplus')
"  set clipboard=unnamedplus
"else
"  set clipboard=unnamed
"endif
set clipboard+=unnamed " share windows clipboard

"home moves cursor to the first non-blank char
noremap <expr> <silent> <Home> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
imap <silent> <Home> <C-O><Home>


"I want mouse settings also ..
set mouse=a
	set viminfo='20,\"50	" read/write a .viminfo file, don't store more
				" than 50 lines of registers
	set history=50000       " keep 50 lines of command line history

"sets color of cursor according to the color of its text ..... looks fundu
set t_vs=[5%dm

"disable all folding
"set nofoldenable

" I work  in javascript also ...
set textwidth=79

"Change buffer - without saving
"buffer to background without saving
set hidden

" I don't like bells .
set noerrorbells
set visualbell
" disable any beeps or flashes on error
set vb t_vb=
""
set virtualedit=block
" echo something on leaving .......
"au VimLeave * echo "Another file ..... gosh I am tired !!"

 " correct these frequent typographical errors
source $HOME/.vim/spell_correct

"source $VIM/macros/file_select.vim
map - :se wrapmargin=0<CR>
map + :se wrapmargin=8<CR>
map K j.
map <C-^> <C-]>

"menu
:source $VIMRUNTIME/menu.vim

"filelist Completion options
set completeopt=longest,menuone
set wildmode=longest,list,full
set wildignorecase
"command line suggestion
set wildmenu
:set cpo-=<
:set wcm=<C-Z>
"":map <F4> :emenu <C-Z>
"visual special charaters
"" Highlight problematic whitespace
if  has("gui_running")
  "set list
  "highlight NonText ctermfg=8 guifg=gray
  "set listchars=tab:§»,extends:¶,eol:¬
endif
"get new chanracters from dig
" use C-k to insert
"set showbreak=§
" Make trailing whitespace annoyingly highlighted.
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
augroup MyAutoCmd
  autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
  autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
  autocmd InsertLeave * match ExtraWhitespace /\s\+$/
  autocmd BufWinLeave * call clearmatches()
  " add this so that future colorscheme changes dont overwrite it"
  autocmd ColorScheme * highlight ExtraWhitespace ctermbg=red guibg=red
augroup END
"set listchars=tab:>.,trail:.,extends:\#,nbsp:.

" kick off emax
"map <F10> :!emacs -nw %<CR>:e!<CR><CR>

" exeute current line
" map <F10> "hyy@h

cnoremap <C-A> <Home>
cnoremap <C-F> <Right>
cnoremap <C-B> <Left>
cnoremap <M-b>  <S-Left>
cnoremap <M-f>  <S-Right>
cnoremap <M-d>  <S-right><Delete>
"make alt arrows to behave like browser"
nnoremap <M-Left> <C-o>
nnoremap <M-Right> <C-i>
cnoremap <ESC>b <S-Left>
cnoremap <Esc>d <S-right><Delete>
cnoremap <ESC>f <S-Right>
cnoremap <ESC><C-H> <C-W>
"buffer navigation
nmap <C-e> :e!<CR>
"ctrlp options
let g:ctrlp_root_markers = 'TOT'
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlPMixed'
let g:ctrlp_working_path_mode = 'ra'
"cursor movement
"j and k should follow the screen
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap <Down> gj
nnoremap <Up> gk
vnoremap <Down> gj
vnoremap <Up> gk
inoremap <Down> <C-o>gj
inoremap <Up> <C-o>gk

"-------------> Edit compressed files <-------------
":autocmd! BufReadPre,FileReadPre  	*.gz set bin
":autocmd  BufReadPost,FileReadPost	*.gz '[,']!gunzip
":autocmd  BufReadPost,FileReadPost	*.gz set nobin
":autocmd! BufWritePost,FileWritePost	*.gz !mv <afile> <afile>:r
":autocmd  BufWritePost,FileWritePost	*.gz !gzip <afile>:r
":autocmd! FileAppendPre			*.gz !gunzip <afile>
":autocmd  FileAppendPre			*.gz !mv <afile>:r <afile>
":autocmd! FileAppendPost		*.gz !mv <afile> <afile>:r
":autocmd  FileAppendPost		*.gz !gzip <afile>:r
"autoload vimrc
augroup myvimrc
    au!
    au BufWritePost .vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC | if has('gui_running') | so $MYVIMRC | endif
augroup END

"-------------> Perl programs <-------------
augroup filetype_perl
:autocmd!
:autocmd BufEnter  *.pl		set ai si cin formatoptions=croql
:autocmd BufLeave  *.pl		set nosi nocin formatoptions=tcq
:autocmd BufEnter  *.pl		set comments=b:#
:autocmd BufLeave  *.pl		set comments=sr:/*,mb:*,el:*/,://,b:#,:%,:XCOMM,n:>,fb:-
augroup END
"without this crontab does not work
augroup filetype_crontab
:autocmd!
:autocmd FileType crontab set backupcopy=yes
augroup END

augroup filetype_snippets
:autocmd!
:autocmd FileType snippets setlocal nomodeline
augroup END

"-------------> Create tags   <-------------
set tags=$HOME/ctags/vrtl/tags

"-------------> C programs and header files <-------------
augroup filetype_java
:autocmd!
:autocmd BufEnter *.java,*.l,*.y,*.c,*.cc,*.h,*.r set ai si cin formatoptions=crql
:autocmd BufLeave *.java,*.l,*.y,*.c,*.cc,*.h,*.r set nosi nocin formatoptions=tcq
":autocmd BufEnter *.java,*.l,*.y,*.c,*.cc,*.h,*.r set comments=sr:/*,mb:*,el:*/,://
":autocmd BufLeave *.java,*.l,*.y,*.c,*.cc,*.h,*.r set comments=sr:/*,mb:*,el:*/,://,b:#,:%,:XCOMM,n:>,fb:-
":autocmd BufEnter *.java,*.l,*.y,*.c,*.cc,*.h,*.r map <F1> :!man -a <cword><CR><CR>
":autocmd BufEnter *.l,*.y,*.c,*.cc,*.h,*.r map <F2> mpI/* <ESC>A */<ESC>`pj
":autocmd BufEnter *.l,*.y,*.c,*.cc,*.h,*.r map <F3> mp^3x$xxx`pj
":autocmd BufEnter *.java                   map <F2> mpI//<ESC>`pj
":autocmd BufEnter *.java                   map <F3> mp^2x`pj
":autocmd BufEnter *.java,*.l,*.y,?akefile*,*.c,*.cc,*.h,*.r map <F4> :!ctags -t *.{c,cc,h}<CR>
":autocmd BufLeave *.java,*.l,*.y,*.c,*.cc,*.h,*.r unmap <F1>
":autocmd BufLeave *.java,*.l,*.y,*.c,*.cc,*.h,*.r unmap <F2>
":autocmd BufLeave *.java,*.l,*.y,*.c,*.cc,*.h,*.r unmap <F3>
":autocmd BufLeave *.java,*.l,*.y,?akefile*,*.c,*.cc,*.h,*.r unmap <F4>
augroup END

augroup filetype_xml
:autocmd!
:autocmd BufEnter *.xml set filetype=xml
:autocmd BufEnter *.xml set foldcolumn=4
let g:xml_syntax_folding=1
:autocmd FileType xml setlocal foldmethod=syntax
:autocmd BufUnload *.xml syntax clear
augroup END

"-------------> Lisp source files <-------------
augroup filetype_lisp
:autocmd!
:autocmd BufEnter  *.l		set lisp sm
:autocmd BufEnter  *.l		source $VIM/syntax/lisp.vim
:autocmd BufEnter  *.l		map <F5> :w<CR>:!akcl < %<CR>
:autocmd BufEnter  *.l		map! <F5> <ESC>:w<CR>:!akcl < %<CR>
:autocmd BufLeave  *.l		set nolisp nosm
:autocmd BufLeave  *.l		unmap <F5>
:autocmd BufLeave  *.l		unmap! <F5>
:autocmd BufLeave  *.l		syntax clear
augroup END

"-------------> TeX & LaTeX source files <-------------
augroup filetype_tex
:autocmd!
:autocmd BufEnter *.tex		map! <F1> }
:autocmd BufEnter *.tex		map! <F2> {\bf
:autocmd BufEnter *.tex		map! <F3> {\em
:autocmd BufEnter *.tex		map! <F4> {\

:autocmd BufEnter *.tex		ab hp hyperplane
:autocmd BufEnter *.tex		ab hps hyperplanes
:autocmd BufEnter *.tex		ab hc hypercube
:autocmd BufEnter *.tex		ab hcs hypercubes
:autocmd BufEnter *.tex		ab nd n-dimensional
:autocmd BufEnter *.tex		ab kd k-dimensional
:autocmd BufEnter *.tex		ab gc graycode
augroup END

"-------------> Haskell source files <-------------
augroup filetype_haskell
:autocmd!
:autocmd BufEnter *.gs		map <F1> :w<CR>:!gofer %<CR>
:autocmd BufLeave *.gs		unmap <F1>
augroup END

augroup filetype_patch
:autocmd!
:autocmd BufEnter *patch* setlocal filetype=patch |setlocal syntax=diff
:autocmd Bufunload *patch* syntax clear
augroup END

augroup filetype_make
:autocmd!
:au BufNewFile,BufRead Makeppfile setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead Makeppfile.* setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead *.make setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead rtlmakefile.inc setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead vplmakefile.inc setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead vcsmakefile.inc setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead *.config setf make |setlocal ts=4 sts=4 sw=4 expandtab
:autocmd BufLeave,FocusLost  Makefile* silent! wall
augroup END

augroup filetype_verilog
:autocmd!
":au BufNewFile,BufRead *.sv setf verilog |set foldmethod=indent/syntax|set foldnestmax=12|set shiftwidth=4|set softtabstop=4|set tabstop=4
":au BufNewFile,BufRead *.sv setf verilog |setlocal foldnestmax=12|setlocal shiftwidth=4|setlocal softtabstop=4|setlocal tabstop=4|setlocal fdc=4|setlocal foldopen+=search|source \~/.vim/cus_fold/folding.vim|call MarkdownSVFolds()
:au BufNewFile,BufRead *.sv setf verilog_systemverilog |setlocal foldnestmax=12|setlocal shiftwidth=4|setlocal softtabstop=4
:au BufNewFile,BufRead *.spp setf verilog
:au BufNewFile,BufRead *.vx setf verilog
:au BufNewFile,BufRead *.v setf verilog
:au BufNewFile,BufRead *.vcp setf verilog
:au BufNewFile,BufRead *.vcp.err setf verilog
:au BufNewFile,BufRead *.vhx setf verilog
:au BufNewFile,BufRead *.vhxcp.err setf verilog
:au BufNewFile,BufRead *.vtx setf verilog
:au BufNewFile,BufRead *.svx setf verilog_systemverilog
:au BufNewFile,BufRead *.svix setf verilog_systemverilog
:au BufNewFile,BufRead *.svcp setf verilog_systemverilog
:au BufNewFile,BufRead *.svi setf verilog_systemverilog
:au BufNewFile,BufRead *.svixcp setf verilog_systemverilog
:au BufNewFile,BufRead *.gv setf verilog
:au BufNewFile,BufRead *.spec setf verilog
:au BufNewFile,BufRead *.vhxcp setf verilog
:au BufNewFile,BufRead *.pl setf perl
:au BufNewFile,BufRead *.pm setf pod|setlocal syntax=perl
:au BufNewFile,BufRead *.svh setf verilog_systemverilog|setlocal foldnestmax=12|setlocal shiftwidth=4|setlocal softtabstop=4
:au BufNewFile,BufRead *.svhx setf verilog_systemverilog
:au BufNewFile,BufRead *.log setlocal wrap
:au BufNewFile,BufRead *.log setf log
:au BufNewFile,BufRead *.log.retry setf log

:au Filetype *verilog* set softtabstop=2
:au BufReadPost * if exists("b:current_syntax")
:au BufReadPost *   if b:current_syntax == "verilog"
:au BufReadPost *     let b:verilog_indent_modules = 1
:au BufReadPost *   endif
:au BufReadPost * endif
  " When editing a file, always jump to the last cursor position
:autocmd BufReadPost *
  \ if line("'\"") > 0 && line ("'\"") <= line("$") |
  \   exe "normal g'\"" |
  \ endif
:au BufReadPost,BufNewFile *
  \ runtime macros/matchit.vim |
  \ let b:match_words = '\<begin\>:\<end\>,\<fork\>:\<join\>,\<module\>:\<endmodule\>,\<task\>:\<endtask\>,\<function\>:\<endfunction\>,\<class\>:\<endclass\>,\<program\>:\<endprogram\>,\<case\>:^[ |<C-I>]*[^"]\+ *\::\<endcase\>,`ifdef:`else:`elsif:`endif,'
augroup END

"-------------> VIVA Files <-------------------------
":source ~/.vim/syntax/viva.vim
":au BufNewFile,BufRead *.vx,*.v set ft=bsv
":au BufNewFile,BufRead *.vhx,*.v set ft=bsv
":au BufNewFile,BufRead *.vtx,*.v set ft=bsv
":au BufNewFile,BufRead *.svx,*.svix set ft=bsv
":au BufNewFile,BufRead *.svcp,*.svi set ft=bsv
"-------------> Html Files <-------------------------
augroup filetype_html
  :autocmd!
  nmap  ,e :e ~/.P/
  map   ,rn :0r ~/.P/txt/New.page.form.html
  nmap  ,p :!chmod 644 %<CR>
  ab Ybr <br>
  ab Yhr <hr>
  ab Yp  <p>
  map ,me yiwi<<ESC>ea></<C-R>"><ESC>
  ab  Ycom  <!--X--><ESC>FXs
  vmap ,com v`<i<!--<ESC>`>i--><ESC>
  ab  Ybl  <blockquote></blockquote><ESC>T>i
  ab  Yb   <b>i</b><ESC>T>
  vmap ,b   "zdi<b><C-R>z</b><ESC>2F>
  ab  Ycen <center></center><ESC>T>i
  vmap ,cen "zdi<center><C-M><C-R>z<C-M></center><ESC>T>i
  ab  Ycod <code></code><ESC>T>i
  vmap ,cod "zdi<code><C-M><C-R>z<C-M></code><C-M><ESC>T>i
  ab  Yi   <i></i><ESC>T>i
  vmap ,i   "zdi<i><C-R>z</i><ESC>T>
  ab  Ytt   <tt></tt><ESC>T>i
  vmap ,tt   "zdi<tt><C-R>z</tt><ESC>T>
  ab  Ypre <pre></pre><ESC>T>i
  vmap ,pre mz:<ESC>'<O<pre><ESC>'>o</pre><ESC>`z
  ab  Yxmp <xmp></xmp><ESC>T>i
  vmap ,xmp mz:<ESC>'<O<xmp><ESC>'>o</xmp><ESC>`z
  ab  Ytd  <td></td><ESC>T>i
  vmap ,td  "zdi<td><C-R>z</td><ESC>T>i
  ab  Ytr  <tr></tr><ESC>T>i
  vmap ,tr  "zdi<tr><C-R>z</tr><ESC>T>i
  ab  Yh1 <h1></h1><ESC>T>i
  vmap ,h1 "zdi<h1><C-R>z</h1><ESC>2F>
  ab  Yh2 <h2></h2><ESC>T>i
  vmap ,h2 "zdi<h2><C-R>z</h2><ESC>2F>
  ab  Yh3 <h3></h3><ESC>T>i
  vmap ,h3 "zdi<h3><C-R>z</h3><ESC>2F>
  ab  Yh4 <h4></h4><ESC>T>i
  vmap ,h4 "zdi<h4><C-R>z</h4><ESC>2F>
  ab  Yh5 <h5></h5><ESC>T>i
  vmap ,h5 "zdi<h5><C-R>z</h5><ESC>2F>
  ab  Yh6 <h6></h6><ESC>T>i
  vmap ,h6 "zdi<h6><C-R>z</h6><ESC>2F>
  ab Yol <ol><CR><li><CR></ol><ESC>k
  ab Yul <ul><CR><li><CR></ul><ESC>k
  ab Ydl <dl><CR><CR><dt><CR><dd><CR><p><CR><CR></dl><CR><ESC>5kA
  ab Yli <li>
  ab Ydt <dt><CR><dd><CR><p><CR><ESC>kA
  ab Ydp <dt><CR><dd><C-M><p><C-M><ESC>kkkA
  ab  Yhref <a href=""></a><ESC>?""<CR>a
  vmap ,href "zdi<a href=""><C-R>z</a><ESC>F"i
  ab  Ylink <a href=""></a><ESC>?""<CR>a
  vmap ,link "zdi<a href="<C-R>z"<C-M><C-I>><C-R>z</a><ESC>F"i
  ab  Yname <a name=""></a><ESC>?""<CR>a
  vmap ,name "zdi<a name="<C-R>z"<C-M><C-I>><C-R>z</a><ESC>2F>
  ab  Yimg  <img alt="[]"<C-M>   align=<C-M>     src=""></a><ESC>?""<CR>a
  ab  Ymail <a href="mailto:"></a><ESC>?:<CR>a
  vmap ,mail "zdi<a href="mailto:<C-R>z"<C-M><C-I><C-I>><C-R>z</a><ESC>2F>
  vmap ,Mail "zdi<a href="mailto:<C-R>z"><C-R>z</a><ESC>2F>
  ab  Ynews <a href="news:"></a><ESC>?:<CR>a
  vmap ,news "zdi<a href="news:<C-R>z"><C-R>z</a><ESC>2F>
  ab  Ypage   <C-M>page:<C-I><C-M>link:<C-I><C-M>text:<C-I><ESC>kkA
  vmap ,Cblu "zdi<FONT COLOR="#0000FF"><C-R>z</FONT>
  vmap ,Cgre "zdi<FONT COLOR="#00FF00"><C-R>z</FONT>
  vmap ,Cred "zdi<FONT COLOR="#FF0000"><C-R>z</FONT>
  imap ;& &amp;
  imap ;" &quot;
  imap ;< &lt;
  imap ;> &gt;
  nmap  ,= :%s/^===\(.*\)$/<h1>\1<\/h1>/c<CR>
  ab  Ycut  \| <a href="#"<C-I>></a><ESC>F#a
  vmap ,cut  "zdi<a href="#<C-R>z"<C-I>><C-R>z</a><ESC>2F>
augroup END

"se bg=light
if  has("gui_running")
    set guitablabel=%N:\ %t#\%-10.3n\ %M
    set background=dark
    "remove toolbar
    "set lines=40
    set guioptions-=T
    set guioptions+=eb
    "set guioptions+=c "console dialog instead of popup"
"--------------preferred--------------------------------------------------------
    "colorscheme darkblue
    "colorscheme wombat "Good
    "colorscheme anotherdark
    "colorscheme blacksea "Good
    "colorscheme camo
    "colorscheme candy
    "colorscheme colorer
    "colorscheme darkZ "Good
    "colorscheme darkspectrum "Good
    "colorscheme zenburn
    "colorscheme rdark
    "colorscheme solarized "Good
    "colorscheme molokai
    "colorscheme two2tango "Good
    "colorscheme evening
    "colorscheme darkblue
    "colorscheme desertEx
    "colorscheme desertedocean
    "colorscheme koehler
    "colorscheme mayansmoke "Good light
    "colorscheme mickeysoft "Good light
    "colorscheme mophiaSmoke "Good light
    "colorscheme gruvbox "Good
    "colorscheme badwolf
    "colorscheme nocturne
    colorscheme molokai
    "colorscheme habilight "Good light
    "colorscheme earendel "white Good
    "colorscheme codeblocks_dark "Good
    "colorscheme manuscript "Good
    "colorscheme mint "Good
    "colorscheme mrpink "Good
    "colorscheme mustang "Good
    "colorscheme moria "little dull
    "FIXME
    "TODO
    "colorscheme jellybeans "Good
    "colorscheme railscasts "Good
    "colorscheme twilight "Good
    "colorscheme molokai "Good
    "colorscheme xoria256 "Good
    "colorscheme symfony
    set cursorline
    """"""""""""""""""""""""""""""
    " => Statusline
    """"""""""""""""""""""""""""""
    let g:Powerline_colorscheme = 'solarized'
"--------------------------------------------------------------------------------
"
"--------------------------------------------------------------------------------
else
    let g:Powerline_colorscheme = 'solarized'
    highlight Normal ctermfg=grey ctermbg=darkblue
    set bg=light
    "set bg=light
    "colorscheme desert
    "colorscheme slate
    "colorscheme aiseered
    "colorscheme manxome
    "colorscheme jellybeans
    "colorscheme candy
    "colorscheme default
    "colorscheme torte
    "colorscheme earendel "Black Good
    "colorscheme default
    colorscheme murphy "Black
    "colorscheme badwolf
    "colorscheme metacosm "Black
    "colorscheme motus "Black
    "colorscheme midnight2 "Blue
    "set guifont=-b&h-lucidatypewriter-medium-r-normal-*-*-140-*-*-m-*-iso8859-15
    se mouse=a
    "se t_Co=256
    "FIXING the arrow problem
    imap <ESC>oA <ESC>ki
    imap <ESC>oB <ESC>ji
    imap <ESC>oC <ESC>li
    imap <ESC>oD <ESC>hi
    "Setting light background
endif
" Turn on cursorline only on active window
augroup MyAutoCmd
  autocmd WinLeave * setlocal nocursorline
  autocmd WinEnter,BufRead * setlocal cursorline
augroup END
"
 " Uncomment the following to have Vim jump to the last position when
 " reopening a file
  if has("autocmd")
    au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
  endif

nmap <F1> h
map <F2> :NERDTreeToggle<CR>
 "If there is an issue in Nerdtree
 "Cannot browse subdirs
let g:NERDTreeDirArrows=0
let NERDTreeShowHidden=1
let NERDTreeIgnore=['\~$', '\.swp$', '\.git', '\.hg', '\.svn', '\.bzr']
let NERDSpaceDelims=1
 "
command! CPWD cd %:p:h
command! LPWD lcd %:p:h
command! TOT lcd `my_depth`
"for replacing a visual
"vmap <C-r> "_dP
vnoremap p "0p
vnoremap P "0P
""""""""""""""""""""""""""""""
" => Visual mode related
""""""""""""""""""""""""""""""
" Really useful!
"  In visual mode when you press * or # to search for the current selection
vnoremap  # :call VisualSearch('f')<CR>
vnoremap  * :call VisualSearch('b')<CR>

" When you press gv you vimgrep after the selected text
"vnoremap <silent> gv :call VisualSearch('gv')<CR>
"noremap <leader>g :vimgrep // **/*.<left><left><left><left><left><left><left>


function! CmdLine(str)
  exe "menu Foo.Bar :" . a:str
  emenu Foo.Bar
  unmenu Foo
endfunction

" From an idea by Michael Naumann
function! VisualSearch(direction) range
  let l:saved_reg = @"
  execute "normal! vgvy"

  let l:pattern = escape(@", '\\/.*$^~[]')
  let l:pattern = substitute(l:pattern, "\n$", "", "")

  if a:direction == 'b'
    execute "normal ?" . l:pattern . "^M"
  elseif a:direction == 'gv'
    call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
  elseif a:direction == 'f'
    execute "normal /" . l:pattern . "^M"
  endif

  let @/ = l:pattern
  let @" = l:saved_reg
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Command mode related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Smart mappings on the command line
cno $c <C-U>sp <C-\>eCurrentFile("sp")<cr>
cno $C <C-U>tabe <C-\>eCurrentFile("tabe")<cr>
cno $p <C-U>sp <C-\>eCurrentFileDir("sp")<cr>
cno $P <C-U>tabe <C-\>eCurrentFileDir("tabe")<cr>
cno $0 <C-U>vs <C-\>eCurrentFileDirP4("vs")<cr>
cno $E <C-U>!p4 edit %
cno $R <C-U>!p4 revert %
cno $A <C-U>!p4 add %
cno $L <C-U>!p4 filelog %
cno $D <C-U>!p4 diff % &
cno $N <C-U>!nedit %
cno $G <C-U>!gnome-terminal &
cno $X <C-U>!xterm -e xx &
cno $K <C-U>!konsole &
cno $M <C-U>!mutt -s "%" -a % $USER@nvidia.com < /dev/null
cno $H <C-U>!p4 have %
cno $S <C-U>!p4 sync %
cno $t <C-U>sp <C-\>eMy_Depth("sp")<cr>/
cno $T <C-U>tabe <C-\>eMy_Depth("tabe")<cr>/
cno $V <C-U>vs <C-\>eMy_Depth("vs")<cr>/
cno $F <C-U>set filetype=verilog_systemverilog
cno $x <C-U>.s/\d\+/\=printf("0x%04x", submatch(0))
cno $Z <C-U>!tar cvf %.tar % && mutt -s "%" -a %.tar $USER@nvidia.com < /dev/null && \rm -f %.tar

" $q is super useful when browsing on the command line
"cno $q <C-\>eDeleteTillSlash()<cr>

" Bash like keys for the command line
func! Cwd()
  let cwd = getcwd()
  return "e " . cwd
endfunc

func! DeleteTillSlash()
  let g:cmd = getcmdline()
  if MySys() == "linux" || MySys() == "mac"
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
  else
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
  endif
  if g:cmd == g:cmd_edited
    if MySys() == "linux" || MySys() == "mac"
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
    else
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
    endif
  endif
  return g:cmd_edited
endfunc

func! CurrentFile(cmd)
  return a:cmd . " ./" . expand("%:p:t:r") . "."
endfunc
func! CurrentFileDir(cmd)
  return a:cmd . " " . expand("%:p:r") . ""
endfunc
func! CurrentFileDirP4(cmd)
  return a:cmd . " | enew | r !p4 print -q " . expand("%:p") . ""
endfunc
function! My_Depth(cmd)
  let output=system("/home/rmondal/bin/scripts/my_depth")
  return a:cmd . " " . output . ""
endfunction
function! My_DepthNoSpace(cmd)
  let output=system("/home/rmondal/bin/scripts/my_depth")
  return a:cmd . "" . output . ""
endfunction
func! CurrentFileUnite(cmd)
  return "Unite -buffer-name=files -input=" . expand("%:p:t:r") . " file_rec:" . a:cmd
endfunc
""""""""""""""""""""""""""""""
" => Statusline
""""""""""""""""""""""""""""""
" Always hide the statusline
let g:Powerline_symbols = 'compatible'
let g:Powerline_cache_enabled = 0
let g:Powerline_mode_V = 'V-L'
let g:Powerline_mode_cv = 'V-B'
let g:Powerline_mode_n = 'N'
let g:Powerline_mode_i = 'I'
let g:Powerline_mode_R = 'R'
let g:Powerline_mode_v = 'V'
if has('gui_running')
  "call Pl#Theme#RemoveSegment('fileencoding')
  "call Pl#Theme#RemoveSegment('fileformat')
  "call Pl#Theme#InsertSegment('filesize', 'before', 'filetype')
  "call Pl#Theme#InsertSegment('pwd', 'before', 'filesize')
  "airline settings
  "nice looking fonts
  let g:airline_inactive_collapse=0
  let g:airline_powerline_fonts=1
  let g:airline_theme='light'
  " remove separators
  "let g:airline_left_sep=''
  "let g:airline_right_sep=''
  " remove unused modes
  "let g:airline_enable_fugitive=0
  "let g:airline_enable_syntastic=0
  " put filetype in fifth section
  let g:airline_section_c = 'Buf#[%n] Path:%{getcwd()} '
  let g:airline_section_b = 'File:%t %m'
  let g:airline_section_x = ""
  let g:airline_section_y = "Type:%Y"
  let g:airline_section_z = "%p%% : Line:%l/%L: Col:%c"
  let g:airline_section_warning = ""
endif

" Format the statusline
" %= is to right align
if !has('gui_running')
  "    "set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c
  "    set statusline=\ %{HasPaste()}%F%m%r%h\ %w\
  "    set statusline+=%=Line:\ %l/%L(%p%%):%c
  "    set statusline+=\
  "    set statusline+=Ftype:
  "    set statusline+=%y
endif

function! CurDir()
  let curdir = substitute(getcwd(), $HOME, "~/", "g")
  return curdir
endfunction

function! HasPaste()
  if &paste
    return 'PASTE MODE  '
  else
    return ''
  endif
endfunction

"set the color of the cursor line
"hi Cursorline
"hi Cursorline cterm=bold ctermbg=None ctermfg=None guibg=#555555
"autocmd InsertEnter * hi Cursorline cterm=Bold ctermbg=None ctermfg=None guibg=black
"autocmd InsertLeave * hi Cursorline cterm=Bold ctermbg=None ctermfg=None guibg=#555555
"highlight cCursor guifg=white guibg=steelblue ctermfg=Black ctermbg=blue
"
"line number highlight
"hi LineNr guifg=black

"*** Search Highlighting ***
"highlight Search ctermbg=DarkCyan
"guibg=blue
"guifg=red
highlight clear Folded
highlight Folded term=bold gui=bold
set foldopen-=search
"call AutoHighlightToggle()
"function AutoHighlightToggle()
"        augroup auto_highlight
"        au!
"        au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
"        augroup end
"        setl updatetime=200
"endfunction
"

"so that i can move out of the terminal
let g:ConqueTerm_ReadUnfocused = 1

"Filter out the greppings
command! -nargs=? Filter let @a='' | execute 'g/<args>/y A' | new | setlocal bt=nofile | put! a


command! -nargs=0 Blame :call P4blame()
function! P4blame()
  exec "!`my_depth`/bin/p4blame %:" . line(".")
endfunction
"MRU CONFIG
let MRU_Exclude_Files = '^/tmp/.*\|^/var/tmp/.*'  " For Unix
let MRU_Max_Entries = 100
"FuzzyFinder
"noremap <F3> :FufFile<CR>
noremap <F4> :FufBuffer<CR>
"noremap <F5> :BufExplorerVerticalSplit<CR>
noremap <F5> :<C-u>GundoToggle<CR>
"let g:tagbar_usearrows = 1
noremap <F3> :TagbarToggle<CR>
"noremap <F7> :YRShow<CR>
nnoremap * *''zz
nnoremap g* g*''zz
nnoremap # #''zz
nnoremap g# g#''zz
"map so that ctrl-g shows the full path"
nnoremap <C-g>  11<C-g>
"Yank from the cursor to the end of the line, to be consistentwith C and D.
nnoremap Y y$
inoremap <c-s> <esc>ddi
"cmap W w
"cmap WQ wq
"cmap wQ wq
"cmap Wq wq
"cmap Q q
"cmap Tabe tabe
" visual shifting (does not exit Visual mode)
"vnoremap < <gv
"vnoremap > >gv

let g:Perl_AuthorName      = 'Rajdeep'
let g:Perl_AuthorRef       = ''
let g:Perl_Email           = '$USER@nvidia'
let g:Perl_Company         = 'nVidia'
"disable boilter plate code insertion"
let g:Perl_TemplateOverwrittenMsg= 'no'

" SnipMate {
" Setting the author var
" If forking, please overwrite in your .vimrc.local file
let g:snips_author = 'Rajdeep <[[$USER@nvidia.com]](mailto:$USER@nvidia.com)>'

"this is only for me
"nnoremap <left> <nop>
"nnoremap <right> <nop>
"nnoremap <up> <nop>
"nnoremap <down> <nop>
if has('win32')
  "Avoid mswin.vim making Ctrl-v as paste
  noremap <C-V> <C-V>
  "make arrow keys extend visual
  set keymodel-=stopsel
  behave win32
  "colorscheme lettuce
  set guifont=Lucida\ Console:h11
  "set guifont=*
  ":FontList
  ":Font Dingbats
  ":FontSize 14
  ":FontStyle bold italic
else
  "set guifont=Courier\ New\ 12
  "set guifont=Droid\ Sans\ Mono\ 12
  "set guifont=Bitstream\ Charter\ 12
  "set guifont=Century\ Schoolbook\ L\ 12
  "set guifont=DejaVu\ Sans\ Mono\ 12
  "
  set guifont=Monaco\ 11
  "set guifont=Andale\ Mono\ 14
  "set guifont=Monofur\ 14
  "set guifont=Consolas\ 13
  "set guifont=Inconsolata\ 14
  "set guifont=Monospace\ 14
  "set guifont=*
  ":FontList
  ":Font Dingbats
  ":FontSize 14
  ":FontStyle bold italic
endif

" Use local vimrc if available {
"if filereadable(expand("\~/.vimrc.local"))
"    source \~/.vimrc.local
"endif
" }
"custom files to source
"if filereadable(expand("\~/.vim/cus_fold/folding.vim"))
"    source \~/.vim/cus_fold/folding.vim
"endif
"fold --> check if file has folding then show foldcolum"
"function HasFoldedLine()
"    let lnum=1
"    while lnum <= line("$")
"        if (foldclosed(lnum) > -1)
"            return 1
"        endif
"        let lnum+=1
"    endwhile
"    return 0
" endfu
":au CursorHold * if HasFoldedLine() == 1 | set fdc=1 | else |set fdc=0 | endif
" Multicursor "
let g:multi_cursor_exit_from_visual_mode=0
let g:multi_cursor_exit_from_insert_mode=0
"Unite configurations"
let g:unite_source_history_yank_enable = 1
let g:unite_source_history_yank_limit=10000
call unite#filters#matcher_default#use(['matcher_fuzzy'])
let g:unite_enable_start_insert=1
let g:unite_source_rec_max_cache_files=100000
call unite#custom#source('file_rec', 'ignore_pattern', '\.abc$')
call unite#custom#source('file_rec', 'max_candidates', '0')
call unite#custom#source('file', 'max_candidates', '0')
"let g:unite_source_grep_command='ack'
"let g:unite_source_grep_default_opts='--no-heading --no-color -a -C4'
"let g:unite_source_grep_recursive_opt=''
"let g:unite_source_find_command =
"    \ 'find `depth` -type f -o \( -name .git -o -name tmp -o -name .hg -name .svn \) -prune -type f | head -100 | grep -v -E "\.(jpe?g|png|gif|[ot]tf|ico)$"'
"let g:unite_source_rec_async_command=
"  \ 'find `depth` -type f -o \( -name .git -o -name tmp -o -name .hg -name .svn \) -prune -type f | head -100 | grep -v -E "\.(jpe?g|png|gif|[ot]tf|ico)$"'
nnoremap <leader>t :<C-u>Unite -buffer-name=files   file_rec:<C-\>eMy_DepthNoSpace("Unite -buffer-name=files   file_rec:")<cr>/
nnoremap <leader>d :<C-u>Unite -buffer-name=files   file_rec:<C-\>eMy_DepthNoSpace("Unite -buffer-name=dir   directory:")<cr>/
nnoremap <leader>f :<C-u>Unite -buffer-name=files   file<cr>
nnoremap <leader>fr :<C-u>Unite -buffer-name=files   file_rec:../../
nnoremap <leader>ft :<C-u><C-\>eCurrentFileUnite("../..")<cr>
nnoremap <leader>o :<C-u>Unite -buffer-name=outline outline<cr>
nnoremap <leader>c :<C-u>Unite -buffer-name=output output<cr>
nnoremap <leader>y :<C-u>Unite -buffer-name=yank    history/yank<cr>
nnoremap <leader>h :<C-u>Unite -buffer-name=yank    history/yank<cr>
nnoremap <leader>r :<C-u>Unite -buffer-name=yank    register<cr>
nnoremap <leader>b :<C-u>Unite -buffer-name=buffer  buffer<cr>
nnoremap <leader>q :<C-u>Unite -buffer-name=quickfix qflist<cr>
nnoremap <leader>g :<C-u>Unite -buffer-name=grep  vimgrep:%<cr>
nnoremap <leader>gb :<C-u>Unite -buffer-name=grep  vimgrep:##<cr>
nnoremap <leader>l :<C-u>Unite -buffer-name=search  line<cr>
autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
  "set paste
  " Play nice with supertab
  let b:SuperTabDisabled=1
  " Overwrite settings.
  imap <silent><buffer><expr> <C-s>     unite#do_action('split')
  imap <silent><buffer><expr> <C-v>     unite#do_action('vsplit')
  "imap <buffer> <esc> <plug>(unite_exit)
  nmap <buffer> <esc> <plug>(unite_exit)
  nmap <buffer> <C-j> <plug>(unite_toggle_auto_preview)
  imap <buffer> <TAB> <plug>(unite_select_next_line)
  imap <buffer> <S-TAB> <plug>(unite_select_previous_line)
  imap <buffer> <BS> <BS>
endfunction

"UltiSnips"
let g:UltiSnipsSnippetDirectories=["UltiSnips", "mysnippets"]
"let g:UltiSnipsExpandTrigger  <c-space>
let g:UltiSnipsListSnippets="<C-Space>"
"let g:UltiSnipsJumpForwardTrigger="<c-j>"
"let g:UltiSnipsJumpBackwardTrigger="<c-k>"

" load filetype detection last"
syntax on
filetype on
filetype plugin on
filetype indent on
